---
layout: page
title: 고급 넘파이
subtitle: 인덱스
minutes: 30
---
> ## 학습목표 {.objectives}
>
> 학습을 마치게 되면, 학습자는 
>
> * N차원 배열에서 어떤 원소든지 뽑아낼 수 있다:
> * 슬라이스 연산자를 사용해서 특정 범위 원소를 가져오고 변경시킬 수 있다.
> * 사본(copy)과 뷰(view)의 차이를 설명할 수 있다. 인덱싱 어떤 방법이 사본 혹은 뷰를 반환하는지 알게 된다.
> * 팬시 인덱스(fancy indexing)를 사용해서 연속되지 않는 원소를 부분배열로 얻어올 수 있다.

### 정수 인덱싱과 슬라이싱

배열에 속한 개별항목을 원소 정수인덱스를 사용해서 접근한다 (인덱스는 0부터 시작):


```
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.array([a[0], a[2], a[-1]])
array([0, 2, 9])
```

2차원 혹은 다차원 배열에 대해서는 인덱스 다수를 지정해야 된다:

```
>>> b = np.arange(6).reshape(2,3)
>>> b
array([[0, 1, 2],
       [3, 4, 5]])
>>> b[1, 2]
5
```

슬라이싱을 사용해서 배열에서 원소 다수를 부분배열로 뽑아낸다.
콜론으로 구분되는 정수 세개를 넣어 정의된다. 즉, `시작:끝:증분`.
기본설정된 값으로 어떤 정수든지 치환되어 건너뛸 수도 있다. 즉, 0은 `시작`, 배열 마지막에 대해서는 `끝`, `증분`에 대해서는 1:

```
>>> c = np.arange(9)
>>> c[1:3]
array([1, 2])
>>> c[:3]
array([0, 1, 2])
>>> c[1:]
array([1, 2, 3, 4, 5, 6, 7, 8])
```

원소를 슬라이스와 인덱스에 대입할 수도 있다:

```
>>> c
array([0, 1, 2, 3, 4, 5, 6, 7, 8])
>>> c[1:8:2]=1000
>>> c
array([   0, 1000,    2, 1000,    4, 1000,    6, 1000,    8])
```

> ## 뷰 혹은 사본 {.challenge}
>
> 0에서 11을 원소값으로 갖는 $3 \times 4$ 배열을 `x`라는 이름으로 생성한다.
> ``y = x[2]`` 명령어로 또다른 배열을 생성한다. 
> `y` 를 변경하면 `x`에는 어떤 일이 발생하는가? &mdash; `x`를 변경하면 어떨가?
> `y = x[:2]`를 시도해보고 첫번재 요소를 변경한다. 이제 무슨 일이 일어날까?
> Create a 3x4 array of  values from 0 to 11.  Create another array as follows: ``y = x[2]``.

> ## 서양장기판 {.challenge}
>
> 배열을 0 으로 채우고, $8 \times 8$ 크기 서양장기판 패턴을 갖는 배열을 생성한다.
>
> ![](fig/checkerboard.svg)

### 부울 마스크

경우에 따라서, 값에 기초해서 배열원소를 골라내고자 하는 경우가 있다.
이런 경우에 부울 마스크(boolean mask)가 매우 유용하다.
마스크는 단지 `True`와 `False` 값만 갖는 인덱스된 배열과 동일한 길이를 갖는 배열이다:


```
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> mask = np.array([False, True, True, False])
>>> a[mask]
array([1, 2])
```

대부분의 경우, 마스크를 배열 그자체에서 생성할 수 있다.
예를 들어, 홀수만 뽑아내려고 한다면, 다음 마스크를 사용한다:

```
>>> odd = (a % 2) == 1
>>> odd
array([False,  True, False,  True], dtype=bool)
>>> a[odd]
array([1, 3])
```

한 단계로 줄여 작업을 완수할 수도 있다:

```
>>> a[(a % 2) == 1]
array([1, 3])
```

마스크를 갖는 인텍스를 사용하여 부분배열에 새로운 값을 대입하는 것도 유용하게 자주 사용되는 기능이다:

```
>>> a[(a % 2) == 1] = -1
>>> a
array([ 0, -1,  2, -1])
```

> ## 뷰 혹은 사본? {.challenge}
>
> 다음 프로그램을 수행하고 나면 마지막에 `a`와 `b` 최종값은 얼마인가? 이유는 무엇인가?
>
> ```
> a = np.arange(5)
> b = a[a < 3]
> b[::2] = 0
> ```
> 
> a) `a = [0, 1, 2, 3, 4], b = [0, 1, 2]`
> b) `a = [0, 1, 0, 3, 4], b = [0, 1, 0]`
> c) `a = [0, 0, 2, 3, 4], b = [0, 0, 2]`
> d) `a = [0, 1, 2, 3, 4], b = [0, 1, 0]`
> e) `a = [0, 1, 2, 3, 4], b = [0, 1, 0, 3, 0]`

> ## 정류(Rectification) {.challenge}
>
> 부울 인덱스를 사용해서 정규분포에서 나온 난수(`np.random.randn` 함수로 생성) 배열을 정류하라. 정류는 음수를 0 으로 치환하는 것이다.
> ```
> >>> rnd = np.random.randn(10)
> >>> rnd[rnd < 0] = 0
> ```

### 팬시 인덱싱(Fancy indexing)

인덱싱을 정수 배열로 작업할 수 있다.
이런 경우, 동일한 인덱스를 여러번 반복할 수도 있다:

```
>>> a = np.arange(0, 100, 10)
>>> a
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
>>> a[[2, 3, 2, 4, 2]] 
array([20, 30, 20, 40, 20])
```

새로운 값을 이런 유형의 인덱싱을 사용해서 대입할 수도 있다:

```
>>> a[[9, 7]] = -100
>>> a
array([   0,   10,   20,   30,   40,   50,   60, -100,   80, -100])
```

새로운 배열을 정수 배열을 인덱싱해서 생성할 때, 새로운 배열은 정수 배열과 동일한 형태를 갖는다.
팬시 인덱싱을 걸면 뷰가 아니라 사본을 반환시킨다.

```
>>> a = np.arange(10)
>>> idx = np.array([[3, 4], [9, 7]])
>>> idx.shape
(2, 2)
>>> a[idx]
array([[3, 4],
       [9, 7]])
```

팬시 인덱싱은 종종 데이터를 정렬하거나 순위를 다시 재조정할 때 사용된다.
손쉽게 `np.argsort`를 사용해서 데이터를 정렬하는데 필요한 인덱스를 얻을 수 있다:

```
>>> a = np.random.randint(10, size=5)
>>> a
array([4, 0, 6, 1, 2])
>>> i = np.argsort(a)
>>> a[i]
array([0, 1, 2, 4, 6])
```

> ## 부분배열(Sub-array) {.challenge}
> 
> 배열을 `x = np.array([1, 5, 10])`로 놓자.
> 
> 다음 명령어 중 어는 것이 [1, 10] 결과값을 보여주는가?:
> 
> a) `x[::2]`
>
> b) `x[[1, 3]]`
> 
> c) `x[[0, 2]]`
> 
> d) `x[0, 2]`
> 
> e) `x[[1, -1]]`
>
> f) `x[[False, True, False]]`
>
> 각문장에 대해 사본 혹은 뷰를 반환하는지 예측해보라.


> ## 임의 원소 {.challenge}
>
> 팬시 인덱스를 사용해서 100개 원소를 갖는 난수 배열에서 복원추출로 10개 원소를 무작위로 뽑으세요.
> (*힌트:* np.random.randint(max_int, size=n)을 사용해서 0 에서 `max_int` 사이 난수 `n`개를 뽑는다.)
> `np.random.randint(100, size=10)`

> ## 비복원 방식으로 임의 정수를 뽑기 {.challenge}
>
> 1 에서 100 사이 숫자에서 정수 10개를 비복원방식으로 생성시킨다. (*힌트:* `np.random.rand`와 `np.argsort`를 사용한다.)
> ```
> >>> rnd = np.random.rand(100)
> >>> i10 = np.argsort(rnd)
> >>> i10[:10]
> ```

